#!/bin/bash

# AppImagr
# Installs latest AppImages from GitHub releases

set -e

# GitHub repository for fetching config and icons
GITHUB_REPO="leomoon-studios/AppImagr"
GITHUB_RAW_URL="https://raw.githubusercontent.com/$GITHUB_REPO/refs/heads/master"

# Check for sudo (not required for --help, --list, or --update)
check_sudo() {
    if [ "$EUID" -ne 0 ]; then
        echo "Please run as root (sudo)"
        exit 1
    fi
}

# Directories
BIN_DIR="/usr/local/bin"
ICON_DIR_SVG="/usr/local/share/icons/hicolor/scalable/apps"
ICON_DIR_PNG="/usr/local/share/icons/hicolor/256x256/apps"
DESKTOP_DIR="/usr/local/share/applications"

install_app() {
    local app_name="$1"
    local repo_url="$2"
    local binary_name="$3"
    local icon_file="$4"
    local comment="$5"
    local categories="$6"
    local startup_wm_class="$7"
    local mime_type="$8"

    echo "--------------------------------------------------"
    echo "Installing $app_name..."

    # Extract Owner/Repo from URL
    # Remove 'https://github.com/'
    local repo_path="${repo_url#https://github.com/}"
    local api_url="https://api.github.com/repos/${repo_path}/releases/latest"

    echo "Fetching latest release info from $api_url..."
    
    # Get the download URL for the AppImage
    # We look for a file ending in .AppImage. 
    # We filter out ARM builds to ensure we get x86_64.
    local download_url=$(curl -s "$api_url" | grep "browser_download_url" | grep -i ".AppImage\"" | grep -v -i "arm" | grep -v -i "arch" | head -n 1 | cut -d '"' -f 4)

    if [ -z "$download_url" ]; then
        echo "Error: Could not find an AppImage download URL for $app_name"
        return 1
    fi

    echo "Found AppImage: $download_url"

    # Download
    echo "Downloading..."
    curl -L -o "$BIN_DIR/$binary_name" "$download_url"

    # Make executable
    chmod +x "$BIN_DIR/$binary_name"
    echo "Installed binary to $BIN_DIR/$binary_name"

    # Install Icon (download from GitHub)
    local icon_url="$GITHUB_RAW_URL/$icon_file"
    local extension="${icon_file##*.}"
    extension="${extension,,}" # Lowercase

    echo "Downloading icon from $icon_url..."
    if [[ "$extension" == "svg" ]]; then
        if curl -sfL -o "$ICON_DIR_SVG/$binary_name.svg" "$icon_url"; then
            echo "Installed icon to $ICON_DIR_SVG/$binary_name.svg"
        else
            echo "Warning: Could not download icon. Trying missing.svg..."
            if curl -sfL -o "$ICON_DIR_SVG/$binary_name.svg" "$GITHUB_RAW_URL/icons/missing.svg"; then
                echo "Installed fallback icon."
            else
                echo "Warning: Could not download fallback icon. Skipping."
            fi
        fi
    elif [[ "$extension" == "png" ]]; then
        if curl -sfL -o "$ICON_DIR_PNG/$binary_name.png" "$icon_url"; then
            echo "Installed icon to $ICON_DIR_PNG/$binary_name.png"
        else
            echo "Warning: Could not download icon. Trying missing.svg..."
            if curl -sfL -o "$ICON_DIR_SVG/$binary_name.svg" "$GITHUB_RAW_URL/icons/missing.svg"; then
                echo "Installed fallback icon."
            else
                echo "Warning: Could not download fallback icon. Skipping."
            fi
        fi
    else
        echo "Warning: Unsupported icon extension '$extension'. Skipping icon installation."
    fi

    # Create Desktop Entry
    local desktop_file="$DESKTOP_DIR/$binary_name.desktop"
    cat > "$desktop_file" <<EOF
[Desktop Entry]
Type=Application
Name=$app_name
Comment=$comment
Exec=$BIN_DIR/$binary_name
Icon=$binary_name
Terminal=false
Categories=$categories
StartupWMClass=$startup_wm_class
MimeType=$mime_type
EOF
    echo "Created desktop entry at $desktop_file"
    
    echo "$app_name installed successfully."
}

# Function to show help
show_help() {
    echo "Usage: $0 [OPTIONS] [APP_NAME...]"
    echo "Downloads or updates AppImages from the AppImagr repository."
    echo ""
    echo "Options:"
    echo "  -a, --all      Download/update all applications"
    echo "  -y, --yes      Automatic yes to prompts (skip confirmation)"
    echo "  -l, --list     List supported applications"
    echo "  -u, --update   Update appimagr itself to the latest version"
    echo "  -h, --help     Show this help message"
    echo ""
    echo "Examples:"
    echo "  sudo $0 --all              # Download/update all apps"
    echo "  sudo $0 pcsx2              # Download/update only PCSX2"
    echo "  sudo $0 cura pcsx2 imhex   # Download/update multiple apps"
    echo "  sudo $0 -y cura pcsx2      # Install without confirmation"
    echo "  sudo $0 --update           # Update appimagr to latest version"
}

# Function to update appimagr itself
update_self() {
    echo "Updating appimagr..."
    local script_url="$GITHUB_RAW_URL/appimagr"
    local tmp_file=$(mktemp)
    
    if curl -sfL -o "$tmp_file" "$script_url"; then
        mv "$tmp_file" "$BIN_DIR/appimagr"
        chmod 755 "$BIN_DIR/appimagr"
        echo "appimagr updated successfully!"
    else
        rm -f "$tmp_file"
        echo "Error: Failed to download the latest version."
        exit 1
    fi
}

# Function to list apps (from remote YAML)
list_apps() {
    echo "Fetching app list from repository..."
    local yaml_content=$(curl -sf "$GITHUB_RAW_URL/apps.yaml")
    
    if [ -z "$yaml_content" ]; then
        echo "Error: Could not fetch apps.yaml from repository."
        exit 1
    fi
    
    echo "Supported applications:"
    while IFS= read -r line || [ -n "$line" ]; do
        # Trim leading/trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        if [[ "$line" =~ ^-\ name:\ (.*) ]]; then
            local name="${BASH_REMATCH[1]}"
            # Remove optional quotes
            name=$(echo "$name" | sed 's/^"//;s/"$//;s/^'"'"'//;s/'"'"'$//')
            echo " - $name"
        fi
    done <<< "$yaml_content"
}

# Main execution

if [[ -z "$1" ]]; then
    show_help
    exit 0
fi

if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    show_help
    exit 0
fi

if [[ "$1" == "-l" ]] || [[ "$1" == "--list" ]]; then
    list_apps
    exit 0
fi

if [[ "$1" == "-u" ]] || [[ "$1" == "--update" ]]; then
    check_sudo
    update_self
    exit 0
fi

# From here on, sudo is required
check_sudo

# Create directories if they don't exist
mkdir -p "$BIN_DIR"
mkdir -p "$ICON_DIR_SVG"
mkdir -p "$ICON_DIR_PNG"
mkdir -p "$DESKTOP_DIR"

# Parse arguments
AUTO_YES=false
INSTALL_ALL=false
TARGET_APPS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        -y|--yes)
            AUTO_YES=true
            shift
            ;;
        -a|--all)
            INSTALL_ALL=true
            shift
            ;;
        *)
            TARGET_APPS+=("$1")
            shift
            ;;
    esac
done

# If --all flag is set, clear TARGET_APPS to install everything
if [ "$INSTALL_ALL" = true ]; then
    TARGET_APPS=()
fi

# Arrays to store apps to install
declare -a APPS_TO_INSTALL_NAMES
declare -a APPS_TO_INSTALL_DATA

# Fetch YAML content from GitHub
echo "Fetching app list from repository..."
YAML_CONTENT=$(curl -sf "$GITHUB_RAW_URL/apps.yaml")

if [ -z "$YAML_CONTENT" ]; then
    echo "Error: Could not fetch apps.yaml from repository."
    exit 1
fi

# Function to collect apps that match the target criteria
collect_apps() {
    local yaml_content="$1"
    local name=""
    local repo=""
    local binary=""
    local icon=""
    local comment=""
    local categories=""
    local startup_wm_class=""
    local mime_type=""

    while IFS= read -r line || [ -n "$line" ]; do
        # Trim leading/trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Skip empty lines and comments
        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^# ]] && continue

        # Check for new item start "- name: ..."
        if [[ "$line" =~ ^-\ name:\ (.*) ]]; then
            # If we have a previous app loaded, check if it should be collected
            if [ -n "$name" ]; then
                should_collect=false
                if [ ${#TARGET_APPS[@]} -eq 0 ]; then
                    should_collect=true
                else
                    for target in "${TARGET_APPS[@]}"; do
                        if [[ "${name,,}" == "${target,,}" ]]; then
                            should_collect=true
                            break
                        fi
                    done
                fi
                if [ "$should_collect" = true ]; then
                    APPS_TO_INSTALL_NAMES+=("$name")
                    # Store app data as a delimited string
                    APPS_TO_INSTALL_DATA+=("$name|$repo|$binary|$icon|$comment|$categories|$startup_wm_class|$mime_type")
                fi
            fi
            
            # Reset variables for new app
            name="${BASH_REMATCH[1]}"
            repo=""
            binary=""
            icon=""
            comment=""
            categories=""
            startup_wm_class=""
            mime_type=""
            
            # Remove optional quotes
            name=$(echo "$name" | sed 's/^"//;s/"$//;s/^'"'"'//;s/'"'"'$//')
            
        elif [[ "$line" =~ ^repo:\ (.*) ]]; then
            repo="${BASH_REMATCH[1]}"
            repo=$(echo "$repo" | sed 's/^"//;s/"$//;s/^'"'"'//;s/'"'"'$//')
            
        elif [[ "$line" =~ ^binary:\ (.*) ]]; then
            binary="${BASH_REMATCH[1]}"
            binary=$(echo "$binary" | sed 's/^"//;s/"$//;s/^'"'"'//;s/'"'"'$//')
            
        elif [[ "$line" =~ ^icon:\ (.*) ]]; then
            icon="${BASH_REMATCH[1]}"
            icon=$(echo "$icon" | sed 's/^"//;s/"$//;s/^'"'"'//;s/'"'"'$//')

        elif [[ "$line" =~ ^comment:\ (.*) ]]; then
            comment="${BASH_REMATCH[1]}"
            comment=$(echo "$comment" | sed 's/^"//;s/"$//;s/^'"'"'//;s/'"'"'$//')

        elif [[ "$line" =~ ^categories:\ (.*) ]]; then
            categories="${BASH_REMATCH[1]}"
            categories=$(echo "$categories" | sed 's/^"//;s/"$//;s/^'"'"'//;s/'"'"'$//')

        elif [[ "$line" =~ ^startup_wm_class:\ (.*) ]]; then
            startup_wm_class="${BASH_REMATCH[1]}"
            startup_wm_class=$(echo "$startup_wm_class" | sed 's/^"//;s/"$//;s/^'"'"'//;s/'"'"'$//')

        elif [[ "$line" =~ ^mime_type:\ (.*) ]]; then
            mime_type="${BASH_REMATCH[1]}"
            mime_type=$(echo "$mime_type" | sed 's/^"//;s/"$//;s/^'"'"'//;s/'"'"'$//')
        fi
    done <<< "$yaml_content"

    # Collect the last app found in the file
    if [ -n "$name" ]; then
        should_collect=false
        if [ ${#TARGET_APPS[@]} -eq 0 ]; then
            should_collect=true
        else
            for target in "${TARGET_APPS[@]}"; do
                if [[ "${name,,}" == "${target,,}" ]]; then
                    should_collect=true
                    break
                fi
            done
        fi
        if [ "$should_collect" = true ]; then
            APPS_TO_INSTALL_NAMES+=("$name")
            APPS_TO_INSTALL_DATA+=("$name|$repo|$binary|$icon|$comment|$categories|$startup_wm_class|$mime_type")
        fi
    fi
}

# Collect apps to install
collect_apps "$YAML_CONTENT"

# Check if any apps were found
if [ ${#APPS_TO_INSTALL_NAMES[@]} -eq 0 ]; then
    echo "No matching applications found."
    exit 1
fi

# Show apps to be installed and ask for confirmation
echo "The following AppImage(s) will be installed/updated:"
echo ""
for app_name in "${APPS_TO_INSTALL_NAMES[@]}"; do
    echo "  - $app_name"
done
echo ""

if [ "$AUTO_YES" = false ]; then
    read -p "Do you want to continue? [Y/n] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]] && [[ ! -z $REPLY ]]; then
        echo "Installation cancelled."
        exit 0
    fi
fi

echo ""
echo "Starting installation..."

# Install collected apps
for app_data in "${APPS_TO_INSTALL_DATA[@]}"; do
    IFS='|' read -r name repo binary icon comment categories startup_wm_class mime_type <<< "$app_data"
    install_app "$name" "$repo" "$binary" "$icon" "$comment" "$categories" "$startup_wm_class" "$mime_type"
done

echo "--------------------------------------------------"
echo "Updating system caches..."

if command -v update-desktop-database &> /dev/null; then
    update-desktop-database "$DESKTOP_DIR" || true
    echo "Desktop database updated."
fi

if command -v gtk-update-icon-cache &> /dev/null; then
    gtk-update-icon-cache -f -t "/usr/local/share/icons/hicolor" || true
    echo "Icon cache updated."
fi

echo "All installations complete."
